#include "AI.h"
#include <cassert>

// This file is used only in the Reach, not the Core.
// You do not need to make any changes to this file for the Core

/*
* Requires: buildingState is a valid state representing the current building
* Modifies: Nothing
* Effects:  Returns a string that represents the decision the AI makes
*           given the current state of the building, which it reads
*           from buildingState.
*           The string should share the exact format as a
*           human player's move input.
*/
// 不存在的人 bool 有= 无！SOLVED
// 10-angerlevel。SOLVED
//angerlevel的floor离得远，anger Level高, turn
// 两个电梯去同一层的情况 update // pickup move? service move? SOLVED
// turn

// pickuo list -- angerlevel SOLVED
// 优化 1st 判断
//加 变量 SOLVED
// *pick list可以优化
string getAIMoveString(const BuildingState& buildingState) {
    string move = "";
    int chosenfloor = 0;
    int distance = 10;
    int maxNum = 0;
    for (int j = 0; j < NUM_FLOORS; j++) {
        if (buildingState.floors[j].numPeople > maxNum) {
            maxNum = buildingState.floors[j].numPeople;
            chosenfloor = j;
        }
    }
    for(int h = 0; h < NUM_FLOORS; h++) {
        if (buildingState.floors[h].numPeople == maxNum) {
            int tempFloor = h;
            for (int k = 0; k < NUM_ELEVATORS; k++) {
                if (distance < min(abs(buildingState.elevators[k].currentFloor - tempFloor), abs(buildingState.elevators[k].currentFloor - chosenfloor))) {
                    distance = min(abs(buildingState.elevators[k].currentFloor - tempFloor), abs(buildingState.elevators[k].currentFloor - chosenfloor));
                }
            }
                for (int i = 0; i < NUM_ELEVATORS; i++) { // i = elevator ID
                if (buildingState.elevators[i].isServicing) {

                }
                else if (buildingState.elevators[i].currentFloor == chosenfloor || buildingState.elevators[i].currentFloor == tempFloor) {
                    // 1st dig
                    move = "e";
                    // 2nd dig
                    char no = '0' + i;
                    move += no;
                    move += "p";
                    return move;
                }
                else if (buildingState.elevators[i].currentFloor != chosenfloor && buildingState.elevators[i].currentFloor != tempFloor) {
                    // 1st dig - chosenfloor < distance) {// service move
                    if (abs(buildingState.elevators[i].currentFloor - tempFloor) > abs(buildingState.elevators[i].currentFloor - chosenfloor)) {
                        move = "e";
                        // 2nd dig
                        char no = '0' + i;
                        move += no;
                        move += "f";
                        char c = '0' + tempFloor;
                        move += c;
                        return move;
                    }
                    else {
                        distance = abs(buildingState.elevators[i].currentFloor - tempFloor);
                        move = "e";
                        // 2nd dig
                        char no = '0' + i;
                        move += no;
                        move += "f";
                        char c = '0' + chosenfloor;
                        move += c;
                        return move;
                    }
                }
            }

        }
    }
    for (int i = 0; i < NUM_ELEVATORS; i++) { // i = elevator ID
        if (buildingState.elevators[i].isServicing) {

        }
        else if (buildingState.elevators[i].currentFloor == chosenfloor) {
            // 1st dig
            if (buildingState.floors[chosenfloor].numPeople == 0) {

            }
            else {
                move = "e";
                // 2nd dig
                char no = '0' + i;
                move += no;
                move += "p";
                return move;
            }
        }
        else if (buildingState.elevators[i].currentFloor != chosenfloor) {
            // 1st dig - chosenfloor < distance) {// service move
            move = "e";
            // 2nd dig
            char no = '0' + i;
            move += no;
            move += "f";
            char c = '0' + chosenfloor;
            move += c;
            return move;

        }
    }
    return move;
}

/*
* Requires: buildingState is a valid state representing the current building
*           move is a pickup move that was generated by getAIMoveString()
*           floorToPickup represents the floor the pickup move occurred.
* Modifies: move
* Effects:  Returns a string representing which people indices
*           should be picked up. The string should share the exact format
*           as a human player's pickup list input.
*/
string getAIPickupList(const Move& move, const BuildingState& buildingState, const Floor& floorToPickup) {
    string list = "";
    string upList = "";
    string downList = "";
    int upSum = 0;
    int downSum = 0;
    for (int i = 0; i < MAX_PEOPLE_PER_FLOOR; i++) {
        // Up
        if (floorToPickup.getPersonByIndex(i).getTargetFloor() > floorToPickup.getPersonByIndex(i).getCurrentFloor()) {
            //sum of up angerlevel
            upSum += 1;
            char c = '0' + i;
            upList += c;

            // down
        }
        else if (floorToPickup.getPersonByIndex(i).getTargetFloor() < floorToPickup.getPersonByIndex(i).getCurrentFloor()) {
            // sum of down angerlevel
            downSum += 1;
            char c = '0' + i;
            downList += c;
        }

    }
    if (upSum >= downSum) {
        // go up first
        return upList;
    }
    else {
        // go down first
        return downList;
    }
    return list;
}